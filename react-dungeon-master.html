<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="description" content="AI-Enhanced Dungeon Master - Classic 1987 dungeon crawler with modern AI assistance"> <meta name="keywords" content="dungeon master, ai game, retro gaming, dungeon crawler"> <meta name="author" content="AI Dungeon Master Team"> <meta property="og:title" content="AI-Enhanced Dungeon Master"> <meta property="og:description" content="Classic dungeon crawler with intelligent AI mentor system"> <meta property="og:type" content="website"> <link rel="preconnect" href="https://unpkg.com"> <link rel="preconnect" href="https://cdn.tailwindcss.com"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>React AI Dungeon Master</title> <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script> <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script> <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script> <script src="https://cdn.tailwindcss.com"></script> <style> body { margin: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; } .animate-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; } @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .5; } } .transition-all { transition-property: all; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; } .duration-150 { transition-duration: 150ms; } .shadow-2xl { box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); } </style> </head> <body> <div id="root"></div> <script type="text/babel"> const { useState, useEffect, useCallback, useRef } = React; const GRID_WIDTH = 20; const GRID_HEIGHT = 15; const CELL_SIZE = 32; // Simple game engine simulation class SimpleGameEngine { constructor() { this.gameState = this.createInitialState(); this.isRunning = false; } createInitialState() { return { player: { position: { x: 3, y: 6 }, health: 100, maxHealth: 100, level: 1 }, enemies: [ { id: '1', position: { x: 10, y: 3 }, health: 50, name: 'goblin' }, { id: '2', position: { x: 15, y: 8 }, health: 75, name: 'orc' } ], items: [ { id: '1', position: { x: 5, y: 4 }, type: 'potion' }, { id: '2', position: { x: 12, y: 7 }, type: 'treasure' }, { id: '3', position: { x: 8, y: 12 }, type: 'weapon' } ], dungeon: { rooms: [ { position: { x: 2, y: 2 }, width: 6, height: 4 }, { position: { x: 10, y: 5 }, width: 8, height: 6 }, { position: { x: 5, y: 10 }, width: 10, height: 4 } ], corridors: [ { path: [ { x: 8, y: 4 }, { x: 9, y: 4 }, { x: 10, y: 5 } ]}, { path: [ { x: 7, y: 6 }, { x: 7, y: 7 }, { x: 7, y: 8 }, { x: 7, y: 9 }, { x: 7, y: 10 } ]} ] }, isInCombat: false, turnNumber: 0 }; } start() { this.isRunning = true; } stop() { this.isRunning = false; } getGameState() { return { ...this.gameState }; } queueAction(action) { this.processAction(action); } processAction(action) { switch (action.type) { case 'move': this.handleMovement(action); break; case 'attack': this.handleAttack(); break; case 'use_item': this.handleUseItem(); break; case 'defend': this.handleDefend(); break; } } handleMovement(action) { const { direction } = action; let dx = 0, dy = 0; switch (direction) { case 'north': dy = -1; break; case 'south': dy = 1; break; case 'west': dx = -1; break; case 'east': dx = 1; break; } const newX = this.gameState.player.position.x + dx; const newY = this.gameState.player.position.y + dy; // Simple bounds checking if (newX >= 0 && newX < GRID_WIDTH && newY >= 0 && newY < GRID_HEIGHT) { // Check if not a wall (simple room/corridor check) const isInRoom = this.gameState.dungeon.rooms.some(room => newX >= room.position.x && newX < room.position.x + room.width && newY >= room.position.y && newY < room.position.y + room.height ); const isInCorridor = this.gameState.dungeon.corridors.some(corridor => corridor.path.some(point => point.x === newX && point.y === newY) ); if (isInRoom || isInCorridor) { this.gameState.player.position.x = newX; this.gameState.player.position.y = newY; // Check for item collection this.gameState.items = this.gameState.items.filter(item => { if (item.position.x === newX && item.position.y === newY) { if (item.type === 'potion') { this.gameState.player.health = Math.min( this.gameState.player.maxHealth, this.gameState.player.health + 20 ); } return false; // Remove item } return true; }); // Check for enemy encounters const nearbyEnemy = this.gameState.enemies.find(enemy => Math.abs(enemy.position.x - newX) <= 1 && Math.abs(enemy.position.y - newY) <= 1 ); if (nearbyEnemy) { this.gameState.isInCombat = true; } } } } handleAttack() { if (this.gameState.isInCombat) { const playerPos = this.gameState.player.position; const nearbyEnemy = this.gameState.enemies.find(enemy => Math.abs(enemy.position.x - playerPos.x) <= 1 && Math.abs(enemy.position.y - playerPos.y) <= 1 ); if (nearbyEnemy) { nearbyEnemy.health -= 25; if (nearbyEnemy.health <= 0) { this.gameState.enemies = this.gameState.enemies.filter(e => e.id !== nearbyEnemy.id); this.gameState.isInCombat = false; } } } } handleUseItem() { if (this.gameState.player.health < this.gameState.player.maxHealth) { this.gameState.player.health = Math.min( this.gameState.player.maxHealth, this.gameState.player.health + 30 ); } } handleDefend() { // Reduce damage for next turn (simplified) console.log('Defending...'); } generateNewDungeon() { // Simple dungeon regeneration this.gameState = this.createInitialState(); this.gameState.player.level += 1; } } function ReactDungeonMaster() { const gameEngineRef = useRef(null); const [gameState, setGameState] = useState({ player: { x: 3, y: 6, health: 100, maxHealth: 100 }, enemies: [], items: [], rooms: [], walls: new Set(), level: 1, score: 0, isInCombat: false }); const [isGameRunning, setIsGameRunning] = useState(false); const [aiMessage, setAiMessage] = useState('Welcome to the AI-Enhanced Dungeon Master!'); // Initialize game engine useEffect(() => { gameEngineRef.current = new SimpleGameEngine(); gameEngineRef.current.start(); setIsGameRunning(true); syncGameState(); return () => { if (gameEngineRef.current) { gameEngineRef.current.stop(); } }; }, []); // Sync game state from engine const syncGameState = useCallback(() => { if (!gameEngineRef.current) return; try { const engineState = gameEngineRef.current.getGameState(); setGameState(prev => ({ ...prev, player: { x: engineState.player.position.x, y: engineState.player.position.y, health: engineState.player.health, maxHealth: engineState.player.maxHealth }, enemies: engineState.enemies.map(enemy => ({ id: enemy.id, x: enemy.position.x, y: enemy.position.y, health: enemy.health, type: enemy.name })), items: engineState.items.map(item => ({ id: item.id, x: item.position.x, y: item.position.y, type: item.type })), rooms: engineState.dungeon.rooms.map(room => ({ x: room.position.x, y: room.position.y, width: room.width, height: room.height })), level: engineState.player.level, isInCombat: engineState.isInCombat })); // Generate walls const wallSet = new Set(); for (let x = 0; x < GRID_WIDTH; x++) { for (let y = 0; y < GRID_HEIGHT; y++) { let isWall = true; // Check if position is inside any room for (const room of engineState.dungeon.rooms) { if (x >= room.position.x && x < room.position.x + room.width && y >= room.position.y && y < room.position.y + room.height) { isWall = false; break; } } // Check if position is on any corridor for (const corridor of engineState.dungeon.corridors) { for (const point of corridor.path) { if (x === point.x && y === point.y) { isWall = false; break; } } } if (isWall) { wallSet.add(`${x},${y}`); } } } setGameState(prev => ({ ...prev, walls: wallSet })); } catch (error) { console.error('Error syncing game state:', error); } }, []); // Game state update loop useEffect(() => { if (!isGameRunning) return; const interval = setInterval(() => { syncGameState(); }, 100); return () => clearInterval(interval); }, [isGameRunning, syncGameState]); // Player movement const movePlayer = useCallback((dx, dy) => { if (!gameEngineRef.current) return; const direction = getDirectionName(dx, dy); if (direction) { const action = { type: 'move', direction: direction, timestamp: Date.now() }; gameEngineRef.current.queueAction(action); // Generate AI response setTimeout(() => { const messages = [ 'Good move! Stay alert for enemies.', 'Exploring the dungeon wisely.', 'Watch your surroundings, adventurer.', 'The dungeon holds many secrets.', 'Keep moving, but be cautious.' ]; setAiMessage(messages[Math.floor(Math.random() * messages.length)]); }, 200); } }, []); const getDirectionName = (dx, dy) => { if (dx === 0 && dy === -1) return 'north'; if (dx === 0 && dy === 1) return 'south'; if (dx === -1 && dy === 0) return 'west'; if (dx === 1 && dy === 0) return 'east'; return null; }; // Combat actions const attack = useCallback(() => { if (!gameEngineRef.current) return; gameEngineRef.current.queueAction({ type: 'attack', timestamp: Date.now() }); setAiMessage('Strike with precision! Analyze your enemy\'s patterns.'); }, []); const useItem = useCallback(() => { if (!gameEngineRef.current) return; gameEngineRef.current.queueAction({ type: 'use_item', timestamp: Date.now() }); setAiMessage('Wise use of resources. Healing is crucial for survival.'); }, []); const defend = useCallback(() => { if (!gameEngineRef.current) return; gameEngineRef.current.queueAction({ type: 'defend', timestamp: Date.now() }); setAiMessage('Defensive stance activated. Reduce incoming damage.'); }, []); const generateNewDungeon = useCallback(() => { if (!gameEngineRef.current) return; gameEngineRef.current.generateNewDungeon(); setGameState(prev => ({ ...prev, level: prev.level + 1, score: prev.score + 100 })); setAiMessage('New dungeon generated! Adapt your strategy to the new layout.'); setTimeout(() => syncGameState(), 100); }, [syncGameState]); // Keyboard controls useEffect(() => { const handleKeyPress = (e) => { switch(e.key) { case 'ArrowUp': case 'w': case 'W': e.preventDefault(); movePlayer(0, -1); break; case 'ArrowDown': case 's': case 'S': e.preventDefault(); movePlayer(0, 1); break; case 'ArrowLeft': case 'a': case 'A': e.preventDefault(); movePlayer(-1, 0); break; case 'ArrowRight': case 'd': case 'D': e.preventDefault(); movePlayer(1, 0); break; case ' ': e.preventDefault(); attack(); break; case 'e': case 'E': e.preventDefault(); useItem(); break; case 'Shift': e.preventDefault(); defend(); break; case 'n': case 'N': e.preventDefault(); generateNewDungeon(); break; } }; window.addEventListener('keydown', handleKeyPress); return () => window.removeEventListener('keydown', handleKeyPress); }, [movePlayer, attack, useItem, defend, generateNewDungeon]); const getEnemyEmoji = (type) => { const emojiMap = { 'goblin': 'ğŸ‘¹', 'orc': 'ğŸ§Œ', 'skeleton': 'ğŸ’€', 'troll': 'ğŸ§Ÿ', 'default': 'ğŸ‘¹' }; return emojiMap[type.toLowerCase()] || emojiMap.default; }; const getItemEmoji = (type) => { const emojiMap = { 'potion': 'ğŸ§ª', 'consumable': 'ğŸ§ª', 'weapon': 'âš”ï¸', 'armor': 'ğŸ›¡ï¸', 'treasure': 'ğŸ’°', 'key': 'ğŸ—ï¸', 'default': 'ğŸ§ª' }; return emojiMap[type.toLowerCase()] || emojiMap.default; }; return ( <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-b from-gray-900 to-black p-4"> {} <div className="mb-4 text-center"> <h1 className="text-4xl font-bold text-green-400 mb-2"> ğŸ® React AI Dungeon Master </h1> <div className="text-white text-lg mb-2"> Level: {gameState.level} | Score: {gameState.score} </div> <div className="text-sm text-gray-300"> Health: {gameState.player.health}/{gameState.player.maxHealth} {gameState.isInCombat && <span className="text-red-400 ml-4">âš”ï¸ IN COMBAT!</span>} </div> </div> {} <div className="mb-4 p-3 bg-blue-900 border-2 border-blue-500 rounded-lg max-w-md"> <div className="text-blue-200 text-sm font-semibold mb-1">ğŸ¤– AI Mentor:</div> <div className="text-white text-sm">{aiMessage}</div> </div> {} <div className="bg-black border-4 border-green-500 relative shadow-2xl" style={{ width: GRID_WIDTH * CELL_SIZE, height: GRID_HEIGHT * CELL_SIZE, }} > {} <div className="absolute inset-0 opacity-10" style={{ backgroundImage: `linear-gradient(90deg, #333 1px, transparent 1px), linear-gradient(#333 1px, transparent 1px)`, backgroundSize: `${CELL_SIZE}px ${CELL_SIZE}px` }} /> {} {gameState.rooms.map((room, index) => ( <div key={`room-${index}`} className="absolute bg-gray-800 opacity-60" style={{ left: room.x * CELL_SIZE, top: room.y * CELL_SIZE, width: room.width * CELL_SIZE, height: room.height * CELL_SIZE, }} /> ))} {} {Array.from(gameState.walls).map(key => { const [x, y] = key.split(',').map(Number); return ( <div key={`wall-${x}-${y}`} className="absolute bg-gray-700" style={{ left: x * CELL_SIZE, top: y * CELL_SIZE, width: CELL_SIZE, height: CELL_SIZE, }} /> ); })} {} {gameState.items.map(item => ( <div key={`item-${item.id}`} className="absolute flex items-center justify-center text-2xl animate-pulse" style={{ left: item.x * CELL_SIZE, top: item.y * CELL_SIZE, width: CELL_SIZE, height: CELL_SIZE, }} > {getItemEmoji(item.type)} </div> ))} {} {gameState.enemies.map(enemy => ( <div key={`enemy-${enemy.id}`} className="absolute flex items-center justify-center text-2xl" style={{ left: enemy.x * CELL_SIZE, top: enemy.y * CELL_SIZE, width: CELL_SIZE, height: CELL_SIZE, }} > {getEnemyEmoji(enemy.type)} {} <div className="absolute top-0 left-0 bg-red-600 h-1" style={{ width: `${(enemy.health / 100) * CELL_SIZE}px` }} /> </div> ))} {} <div className="absolute flex items-center justify-center text-3xl transition-all duration-150 z-10" style={{ left: gameState.player.x * CELL_SIZE, top: gameState.player.y * CELL_SIZE, width: CELL_SIZE, height: CELL_SIZE, }} > ğŸ§™â€â™‚ï¸ {} <div className="absolute top-0 left-0 bg-green-500 h-2" style={{ width: `${(gameState.player.health / gameState.player.maxHealth) * CELL_SIZE}px` }} /> </div> </div> {} <div className="mt-6 text-center"> <div className="grid grid-cols-2 gap-4 mb-4"> <button onClick={() => movePlayer(0, -1)} className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded font-semibold" > â†‘ Move Up </button> <button onClick={attack} className="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded font-semibold" > âš”ï¸ Attack </button> <button onClick={() => movePlayer(-1, 0)} className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded font-semibold" > â† Move Left </button> <button onClick={() => movePlayer(1, 0)} className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded font-semibold" > â†’ Move Right </button> <button onClick={() => movePlayer(0, 1)} className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded font-semibold" > â†“ Move Down </button> <button onClick={useItem} className="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded font-semibold" > ğŸ§ª Use Item </button> </div> <div className="grid grid-cols-2 gap-4 mb-4"> <button onClick={defend} className="px-4 py-2 bg-yellow-600 hover:bg-yellow-700 text-white rounded font-semibold" > ğŸ›¡ï¸ Defend </button> <button onClick={generateNewDungeon} className="px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded font-semibold" > ğŸ° New Dungeon </button> </div> <div className="text-white text-sm space-y-1"> <p><strong>Keyboard Controls:</strong></p> <p>WASD/Arrow Keys: Move | Space: Attack | E: Use Item</p> <p>Shift: Defend | N: New Dungeon</p> <p>Collect items ğŸ§ª and avoid enemies ğŸ‘¹</p> </div> </div> </div> ); } // Render the app ReactDOM.render(<ReactDungeonMaster />, document.getElementById('root')); </script> </body> </html>
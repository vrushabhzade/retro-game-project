<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fast AI Dungeon Master</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Courier New', monospace; 
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #00ff00;
            overflow-x: hidden;
        }
        .container { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            min-height: 100vh; 
            padding: 20px;
        }
        .header { text-align: center; margin-bottom: 20px; }
        .title { 
            font-size: 2.5em; 
            text-shadow: 0 0 20px #00ff00;
            margin-bottom: 10px;
        }
        .stats { 
            font-size: 1.2em; 
            margin-bottom: 10px;
        }
        .ai-panel { 
            background: rgba(0, 50, 100, 0.8); 
            border: 2px solid #0066ff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            max-width: 400px;
            text-align: center;
        }
        .ai-label { 
            color: #66ccff; 
            font-weight: bold; 
            margin-bottom: 5px;
        }
        .game-grid { 
            background: #000; 
            border: 4px solid #00ff00;
            position: relative;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.3);
        }
        .grid-bg {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            opacity: 0.1;
            background-image: 
                linear-gradient(90deg, #333 1px, transparent 1px),
                linear-gradient(#333 1px, transparent 1px);
        }
        .room { 
            position: absolute; 
            background: rgba(128, 128, 128, 0.3);
        }
        .wall { 
            position: absolute; 
            background: #555;
        }
        .item { 
            position: absolute; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            font-size: 20px;
            animation: pulse 2s infinite;
        }
        .enemy { 
            position: absolute; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            font-size: 20px;
        }
        .player { 
            position: absolute; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            font-size: 24px;
            z-index: 10;
            transition: all 0.15s ease;
        }
        .health-bar { 
            position: absolute; 
            top: 0; 
            left: 0; 
            height: 2px;
        }
        .controls { 
            margin-top: 20px; 
            text-align: center;
        }
        .btn-grid { 
            display: grid; 
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
            max-width: 300px;
        }
        .btn { 
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }
        .btn-move { background: #0066cc; color: white; }
        .btn-move:hover { background: #0088ff; }
        .btn-attack { background: #cc0000; color: white; }
        .btn-attack:hover { background: #ff0000; }
        .btn-item { background: #00cc00; color: white; }
        .btn-item:hover { background: #00ff00; }
        .btn-defend { background: #ccaa00; color: white; }
        .btn-defend:hover { background: #ffdd00; }
        .btn-dungeon { background: #6600cc; color: white; }
        .btn-dungeon:hover { background: #8800ff; }
        .instructions { 
            color: #ccc; 
            font-size: 12px; 
            line-height: 1.4;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .loading {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">üéÆ Loading AI Dungeon Master...</div>
    <div id="game" class="container" style="display: none;">
        <div class="header">
            <h1 class="title">üéÆ Fast AI Dungeon Master</h1>
            <div class="stats">
                Level: <span id="level">1</span> | Score: <span id="score">0</span>
            </div>
            <div class="stats">
                Health: <span id="health">100</span>/<span id="maxHealth">100</span>
                <span id="combat" style="color: #ff4444; display: none;"> ‚öîÔ∏è IN COMBAT!</span>
            </div>
        </div>

        <div class="ai-panel">
            <div class="ai-label">ü§ñ AI Mentor:</div>
            <div id="aiMessage">Welcome to the AI-Enhanced Dungeon Master!</div>
        </div>

        <div id="gameGrid" class="game-grid">
            <div class="grid-bg"></div>
        </div>

        <div class="controls">
            <div class="btn-grid">
                <button class="btn btn-move" onclick="movePlayer(0, -1)">‚Üë Up</button>
                <button class="btn btn-attack" onclick="attack()">‚öîÔ∏è Attack</button>
                <button class="btn btn-move" onclick="movePlayer(-1, 0)">‚Üê Left</button>
                <button class="btn btn-move" onclick="movePlayer(1, 0)">‚Üí Right</button>
                <button class="btn btn-move" onclick="movePlayer(0, 1)">‚Üì Down</button>
                <button class="btn btn-item" onclick="useItem()">üß™ Use Item</button>
            </div>
            <div class="btn-grid">
                <button class="btn btn-defend" onclick="defend()">üõ°Ô∏è Defend</button>
                <button class="btn btn-dungeon" onclick="newDungeon()">üè∞ New Dungeon</button>
            </div>
            <div class="instructions">
                <strong>Controls:</strong> WASD/Arrow Keys: Move | Space: Attack | E: Use Item<br>
                Shift: Defend | N: New Dungeon | Collect items üß™ and avoid enemies üëπ
            </div>
        </div>
    </div>

    <script>
        // Fast, lightweight game engine
        const GRID_WIDTH = 20;
        const GRID_HEIGHT = 15;
        const CELL_SIZE = 32;

        let gameState = {
            player: { x: 3, y: 6, health: 100, maxHealth: 100 },
            enemies: [
                { id: 1, x: 10, y: 3, health: 50, type: 'goblin' },
                { id: 2, x: 15, y: 8, health: 75, type: 'orc' }
            ],
            items: [
                { id: 1, x: 5, y: 4, type: 'potion' },
                { id: 2, x: 12, y: 7, type: 'treasure' },
                { id: 3, x: 8, y: 12, type: 'weapon' }
            ],
            rooms: [
                { x: 2, y: 2, width: 6, height: 4 },
                { x: 10, y: 5, width: 8, height: 6 },
                { x: 5, y: 10, width: 10, height: 4 }
            ],
            walls: new Set(),
            level: 1,
            score: 0,
            isInCombat: false
        };

        const aiMessages = [
            'Good move! Stay alert for enemies.',
            'Exploring the dungeon wisely.',
            'Watch your surroundings, adventurer.',
            'The dungeon holds many secrets.',
            'Keep moving, but be cautious.',
            'Strike with precision! Analyze enemy patterns.',
            'Wise use of resources. Healing is crucial.',
            'Defensive stance activated. Reduce damage.',
            'New dungeon generated! Adapt your strategy.'
        ];

        function generateWalls() {
            const walls = new Set();
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    let isWall = true;
                    
                    // Check rooms
                    for (const room of gameState.rooms) {
                        if (x >= room.x && x < room.x + room.width &&
                            y >= room.y && y < room.y + room.height) {
                            isWall = false;
                            break;
                        }
                    }
                    
                    // Simple corridors
                    if ((x === 8 && y >= 4 && y <= 5) || 
                        (x === 7 && y >= 6 && y <= 10)) {
                        isWall = false;
                    }
                    
                    if (isWall) walls.add(`${x},${y}`);
                }
            }
            gameState.walls = walls;
        }

        function isValidMove(x, y) {
            return x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT && 
                   !gameState.walls.has(`${x},${y}`);
        }

        function movePlayer(dx, dy) {
            const newX = gameState.player.x + dx;
            const newY = gameState.player.y + dy;
            
            if (isValidMove(newX, newY)) {
                gameState.player.x = newX;
                gameState.player.y = newY;
                
                // Check items
                gameState.items = gameState.items.filter(item => {
                    if (item.x === newX && item.y === newY) {
                        if (item.type === 'potion') {
                            gameState.player.health = Math.min(gameState.player.maxHealth, 
                                                             gameState.player.health + 20);
                        }
                        gameState.score += 10;
                        return false;
                    }
                    return true;
                });
                
                // Check combat
                const nearEnemy = gameState.enemies.find(e => 
                    Math.abs(e.x - newX) <= 1 && Math.abs(e.y - newY) <= 1);
                gameState.isInCombat = !!nearEnemy;
                
                showAIMessage(aiMessages[Math.floor(Math.random() * 5)]);
                render();
            }
        }

        function attack() {
            if (gameState.isInCombat) {
                const nearEnemy = gameState.enemies.find(e => 
                    Math.abs(e.x - gameState.player.x) <= 1 && 
                    Math.abs(e.y - gameState.player.y) <= 1);
                
                if (nearEnemy) {
                    nearEnemy.health -= 25;
                    if (nearEnemy.health <= 0) {
                        gameState.enemies = gameState.enemies.filter(e => e.id !== nearEnemy.id);
                        gameState.score += 50;
                        gameState.isInCombat = false;
                    }
                    showAIMessage(aiMessages[5]);
                    render();
                }
            }
        }

        function useItem() {
            if (gameState.player.health < gameState.player.maxHealth) {
                gameState.player.health = Math.min(gameState.player.maxHealth, 
                                                 gameState.player.health + 30);
                showAIMessage(aiMessages[6]);
                render();
            }
        }

        function defend() {
            showAIMessage(aiMessages[7]);
        }

        function newDungeon() {
            gameState.level++;
            gameState.score += 100;
            gameState.player.x = 3;
            gameState.player.y = 6;
            gameState.enemies = [
                { id: Date.now(), x: Math.floor(Math.random() * GRID_WIDTH), 
                  y: Math.floor(Math.random() * GRID_HEIGHT), health: 50, type: 'goblin' },
                { id: Date.now() + 1, x: Math.floor(Math.random() * GRID_WIDTH), 
                  y: Math.floor(Math.random() * GRID_HEIGHT), health: 75, type: 'orc' }
            ];
            generateWalls();
            showAIMessage(aiMessages[8]);
            render();
        }

        function showAIMessage(message) {
            document.getElementById('aiMessage').textContent = message;
        }

        function render() {
            console.log('Rendering game state...');
            
            // Update stats (with null checks)
            const levelEl = document.getElementById('level');
            const scoreEl = document.getElementById('score');
            const healthEl = document.getElementById('health');
            const maxHealthEl = document.getElementById('maxHealth');
            const combatEl = document.getElementById('combat');
            
            if (levelEl) levelEl.textContent = gameState.level;
            if (scoreEl) scoreEl.textContent = gameState.score;
            if (healthEl) healthEl.textContent = gameState.player.health;
            if (maxHealthEl) maxHealthEl.textContent = gameState.player.maxHealth;
            if (combatEl) combatEl.style.display = gameState.isInCombat ? 'inline' : 'none';
            
            // Clear grid
            const grid = document.getElementById('gameGrid');
            if (!grid) {
                console.error('Game grid element not found!');
                return;
            }
            
            grid.innerHTML = '<div class="grid-bg"></div>';
            grid.style.width = GRID_WIDTH * CELL_SIZE + 'px';
            grid.style.height = GRID_HEIGHT * CELL_SIZE + 'px';
            
            // Set grid background
            const bg = grid.querySelector('.grid-bg');
            bg.style.backgroundSize = `${CELL_SIZE}px ${CELL_SIZE}px`;
            
            // Render rooms
            gameState.rooms.forEach((room, i) => {
                const roomEl = document.createElement('div');
                roomEl.className = 'room';
                roomEl.style.left = room.x * CELL_SIZE + 'px';
                roomEl.style.top = room.y * CELL_SIZE + 'px';
                roomEl.style.width = room.width * CELL_SIZE + 'px';
                roomEl.style.height = room.height * CELL_SIZE + 'px';
                grid.appendChild(roomEl);
            });
            
            // Render walls
            gameState.walls.forEach(wall => {
                const [x, y] = wall.split(',').map(Number);
                const wallEl = document.createElement('div');
                wallEl.className = 'wall';
                wallEl.style.left = x * CELL_SIZE + 'px';
                wallEl.style.top = y * CELL_SIZE + 'px';
                wallEl.style.width = CELL_SIZE + 'px';
                wallEl.style.height = CELL_SIZE + 'px';
                grid.appendChild(wallEl);
            });
            
            // Render items
            gameState.items.forEach(item => {
                const itemEl = document.createElement('div');
                itemEl.className = 'item';
                itemEl.style.left = item.x * CELL_SIZE + 'px';
                itemEl.style.top = item.y * CELL_SIZE + 'px';
                itemEl.style.width = CELL_SIZE + 'px';
                itemEl.style.height = CELL_SIZE + 'px';
                itemEl.textContent = item.type === 'potion' ? 'üß™' : 
                                   item.type === 'treasure' ? 'üí∞' : '‚öîÔ∏è';
                grid.appendChild(itemEl);
            });
            
            // Render enemies
            gameState.enemies.forEach(enemy => {
                const enemyEl = document.createElement('div');
                enemyEl.className = 'enemy';
                enemyEl.style.left = enemy.x * CELL_SIZE + 'px';
                enemyEl.style.top = enemy.y * CELL_SIZE + 'px';
                enemyEl.style.width = CELL_SIZE + 'px';
                enemyEl.style.height = CELL_SIZE + 'px';
                enemyEl.textContent = enemy.type === 'goblin' ? 'üëπ' : 'üßå';
                
                // Health bar
                const healthBar = document.createElement('div');
                healthBar.className = 'health-bar';
                healthBar.style.background = '#ff0000';
                healthBar.style.width = (enemy.health / 100) * CELL_SIZE + 'px';
                enemyEl.appendChild(healthBar);
                
                grid.appendChild(enemyEl);
            });
            
            // Render player
            const playerEl = document.createElement('div');
            playerEl.className = 'player';
            playerEl.style.left = gameState.player.x * CELL_SIZE + 'px';
            playerEl.style.top = gameState.player.y * CELL_SIZE + 'px';
            playerEl.style.width = CELL_SIZE + 'px';
            playerEl.style.height = CELL_SIZE + 'px';
            playerEl.textContent = 'üßô‚Äç‚ôÇÔ∏è';
            
            // Player health bar
            const playerHealthBar = document.createElement('div');
            playerHealthBar.className = 'health-bar';
            playerHealthBar.style.background = '#00ff00';
            playerHealthBar.style.height = '3px';
            playerHealthBar.style.width = (gameState.player.health / gameState.player.maxHealth) * CELL_SIZE + 'px';
            playerEl.appendChild(playerHealthBar);
            
            grid.appendChild(playerEl);
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp': case 'w': case 'W':
                    e.preventDefault(); movePlayer(0, -1); break;
                case 'ArrowDown': case 's': case 'S':
                    e.preventDefault(); movePlayer(0, 1); break;
                case 'ArrowLeft': case 'a': case 'A':
                    e.preventDefault(); movePlayer(-1, 0); break;
                case 'ArrowRight': case 'd': case 'D':
                    e.preventDefault(); movePlayer(1, 0); break;
                case ' ': e.preventDefault(); attack(); break;
                case 'e': case 'E': e.preventDefault(); useItem(); break;
                case 'Shift': e.preventDefault(); defend(); break;
                case 'n': case 'N': e.preventDefault(); newDungeon(); break;
            }
        });

        // Initialize game
        function initGame() {
            console.log('Initializing game...');
            generateWalls();
            render();
            
            // Hide loading screen and show game
            setTimeout(() => {
                const loading = document.getElementById('loading');
                const game = document.getElementById('game');
                
                if (loading) loading.style.display = 'none';
                if (game) game.style.display = 'flex';
                
                console.log('Game initialized successfully!');
            }, 500); // Small delay to show loading
        }

        // Fast loading with multiple fallbacks
        function startGame() {
            try {
                initGame();
            } catch (error) {
                console.error('Game initialization error:', error);
                // Fallback: show game anyway
                document.getElementById('loading').style.display = 'none';
                document.getElementById('game').style.display = 'flex';
            }
        }

        // Multiple initialization methods
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', startGame);
        } else {
            startGame();
        }

        // Backup initialization after 2 seconds
        setTimeout(() => {
            const loading = document.getElementById('loading');
            if (loading && loading.style.display !== 'none') {
                console.log('Backup initialization triggered');
                startGame();
            }
        }, 2000);
    </script>
</body>
</html>
<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="description" content="AI-Enhanced Dungeon Master - Classic 1987 dungeon crawler with modern AI assistance"> <meta name="keywords" content="dungeon master, ai game, retro gaming, dungeon crawler"> <meta name="author" content="AI Dungeon Master Team"> <meta property="og:title" content="AI-Enhanced Dungeon Master"> <meta property="og:description" content="Classic dungeon crawler with intelligent AI mentor system"> <meta property="og:type" content="website"> <link rel="preconnect" href="https://unpkg.com"> <link rel="preconnect" href="https://cdn.tailwindcss.com"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>AI Dungeon Master - Simple Game</title> <style> body { margin: 0; padding: 20px; background: linear-gradient(135deg, #1a1a2e, #16213e); color: #eee; font-family: 'Courier New', monospace; min-height: 100vh; } .container { max-width: 1200px; margin: 0 auto; } .header { text-align: center; margin-bottom: 20px; } .header h1 { color: #4CAF50; font-size: 2.5em; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); } .game-container { display: flex; gap: 20px; justify-content: center; align-items: flex-start; } .game-canvas { border: 3px solid #4CAF50; border-radius: 10px; background: #000; box-shadow: 0 0 20px rgba(76, 175, 80, 0.3); } .info-panel { background: rgba(0,0,0,0.3); border: 2px solid #2196F3; border-radius: 10px; padding: 20px; width: 300px; max-height: 600px; overflow-y: auto; } .info-panel h3 { color: #2196F3; margin-top: 0; } .controls { margin-bottom: 20px; } .control-item { display: flex; justify-content: space-between; margin-bottom: 8px; padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.1); } .key { background: #333; padding: 2px 6px; border-radius: 3px; font-weight: bold; color: #4CAF50; } .status { margin-bottom: 20px; } .status-item { display: flex; justify-content: space-between; margin-bottom: 5px; } .status-value { color: #4CAF50; font-weight: bold; } .log { background: rgba(0,0,0,0.5); border: 1px solid #555; border-radius: 5px; padding: 10px; height: 200px; overflow-y: auto; font-size: 12px; } .log-entry { margin-bottom: 3px; opacity: 0.8; } .log-entry.info { color: #4CAF50; } .log-entry.error { color: #f44336; } .log-entry.warn { color: #FF9800; } .btn { background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-family: inherit; font-weight: bold; margin: 5px; } .btn:hover { background: #45a049; } .btn.secondary { background: #2196F3; } .btn.secondary:hover { background: #1976D2; } </style> </head> <body> <div class="container"> <div class="header"> <h1>ðŸŽ® AI Dungeon Master</h1> <p>Classic dungeon crawler with modern AI enhancements</p> </div> <div class="game-container"> <canvas id="game-canvas" class="game-canvas" width="800" height="600"></canvas> <div class="info-panel"> <h3>ðŸŽ¯ Controls</h3> <div class="controls"> <div class="control-item"> <span><span class="key">WASD</span> or <span class="key">Arrows</span></span> <span>Move</span> </div> <div class="control-item"> <span><span class="key">Space</span></span> <span>Attack</span> </div> <div class="control-item"> <span><span class="key">E</span></span> <span>Use Item</span> </div> <div class="control-item"> <span><span class="key">Shift</span></span> <span>Defend</span> </div> <div class="control-item"> <span><span class="key">N</span></span> <span>New Dungeon</span> </div> <div class="control-item"> <span><span class="key">P</span></span> <span>Performance</span> </div> </div> <h3>ðŸ“Š Game Status</h3> <div class="status" id="game-status"> <div class="status-item"> <span>Health:</span> <span class="status-value" id="health">100/100</span> </div> <div class="status-item"> <span>Level:</span> <span class="status-value" id="level">1</span> </div> <div class="status-item"> <span>Experience:</span> <span class="status-value" id="experience">0</span> </div> <div class="status-item"> <span>Room:</span> <span class="status-value" id="room">-</span> </div> <div class="status-item"> <span>Combat:</span> <span class="status-value" id="combat">No</span> </div> </div> <h3>ðŸŽ® Actions</h3> <button class="btn" onclick="newDungeon()">New Dungeon</button> <button class="btn secondary" onclick="showPerformance()">Performance</button> <button class="btn secondary" onclick="togglePause()">Pause/Resume</button> <h3>ðŸ“‹ Game Log</h3> <div class="log" id="game-log"></div> </div> </div> </div> <script type="module"> // Simple game implementation without TypeScript compilation class SimpleGameRunner { constructor() { this.canvas = document.getElementById('game-canvas'); this.ctx = this.canvas.getContext('2d'); this.gameState = this.createInitialGameState(); this.isRunning = false; this.lastFrameTime = 0; this.setupEventHandlers(); this.start(); } createInitialGameState() { return { player: { position: { x: 10, y: 10 }, health: 100, maxHealth: 100, level: 1, experience: 0 }, dungeon: { rooms: [ { position: { x: 5, y: 5 }, width: 10, height: 8 }, { position: { x: 20, y: 10 }, width: 8, height: 6 }, { position: { x: 15, y: 20 }, width: 12, height: 10 } ], corridors: [ { path: [ { x: 15, y: 9 }, { x: 16, y: 9 }, { x: 17, y: 9 }, { x: 18, y: 9 }, { x: 19, y: 9 }, { x: 20, y: 10 } ]} ] }, enemies: [ { position: { x: 22, y: 12 }, health: 30, maxHealth: 30, name: 'Goblin' }, { position: { x: 18, y: 25 }, health: 50, maxHealth: 50, name: 'Orc' } ], items: [ { position: { x: 12, y: 8 }, type: 'potion' }, { position: { x: 25, y: 15 }, type: 'treasure' } ], currentRoom: 'room-1', isInCombat: false, turnNumber: 0 }; } setupEventHandlers() { document.addEventListener('keydown', (event) => { this.handleKeyPress(event); }); } handleKeyPress(event) { const direction = this.getDirectionFromKey(event.key); if (direction) { this.movePlayer(direction); event.preventDefault(); return; } switch (event.key.toLowerCase()) { case ' ': this.attack(); event.preventDefault(); break; case 'e': this.useItem(); event.preventDefault(); break; case 'n': this.generateNewDungeon(); event.preventDefault(); break; case 'p': this.showPerformanceInfo(); event.preventDefault(); break; } } getDirectionFromKey(key) { switch (key.toLowerCase()) { case 'w': case 'arrowup': return { x: 0, y: -1 }; case 's': case 'arrowdown': return { x: 0, y: 1 }; case 'a': case 'arrowleft': return { x: -1, y: 0 }; case 'd': case 'arrowright': return { x: 1, y: 0 }; default: return null; } } movePlayer(direction) { const newX = this.gameState.player.position.x + direction.x; const newY = this.gameState.player.position.y + direction.y; // Simple bounds checking if (newX >= 0 && newX < 40 && newY >= 0 && newY < 30) { this.gameState.player.position.x = newX; this.gameState.player.position.y = newY; this.checkCollisions(); this.log(`Moved to (${newX}, ${newY})`, 'info'); } } checkCollisions() { const playerPos = this.gameState.player.position; // Check enemy collisions for (let i = 0; i < this.gameState.enemies.length; i++) { const enemy = this.gameState.enemies[i]; if (enemy.health > 0 && enemy.position.x === playerPos.x && enemy.position.y === playerPos.y) { this.startCombat(enemy); break; } } // Check item collisions for (let i = this.gameState.items.length - 1; i >= 0; i--) { const item = this.gameState.items[i]; if (item.position.x === playerPos.x && item.position.y === playerPos.y) { this.collectItem(item, i); } } } startCombat(enemy) { this.gameState.isInCombat = true; this.log(`Combat started with ${enemy.name}!`, 'warn'); } attack() { if (this.gameState.isInCombat) { const damage = 15 + Math.floor(Math.random() * 10); // Find nearby enemy const playerPos = this.gameState.player.position; for (const enemy of this.gameState.enemies) { if (enemy.health > 0 && Math.abs(enemy.position.x - playerPos.x) <= 1 && Math.abs(enemy.position.y - playerPos.y) <= 1) { enemy.health = Math.max(0, enemy.health - damage); this.log(`Attacked ${enemy.name} for ${damage} damage!`, 'info'); if (enemy.health === 0) { this.gameState.isInCombat = false; this.gameState.player.experience += 25; this.log(`${enemy.name} defeated! +25 XP`, 'info'); } break; } } } else { this.log('No enemies nearby to attack', 'warn'); } } useItem() { // Simple healing if (this.gameState.player.health < this.gameState.player.maxHealth) { this.gameState.player.health = Math.min( this.gameState.player.maxHealth, this.gameState.player.health + 20 ); this.log('Used healing potion! +20 HP', 'info'); } else { this.log('Already at full health', 'warn'); } } collectItem(item, index) { this.gameState.items.splice(index, 1); if (item.type === 'potion') { this.log('Collected healing potion!', 'info'); } else if (item.type === 'treasure') { this.gameState.player.experience += 50; this.log('Found treasure! +50 XP', 'info'); } } generateNewDungeon() { // Simple dungeon generation const rooms = []; const numRooms = 3 + Math.floor(Math.random() * 3); for (let i = 0; i < numRooms; i++) { rooms.push({ position: { x: Math.floor(Math.random() * 25) + 5, y: Math.floor(Math.random() * 20) + 5 }, width: 6 + Math.floor(Math.random() * 8), height: 4 + Math.floor(Math.random() * 6) }); } this.gameState.dungeon.rooms = rooms; this.gameState.player.position = { x: 10, y: 10 }; this.log('Generated new dungeon!', 'info'); } showPerformanceInfo() { const fps = Math.round(1000 / (performance.now() - this.lastFrameTime)); this.log(`Performance: ${fps} FPS`, 'info'); } start() { this.isRunning = true; this.gameLoop(); } gameLoop() { if (!this.isRunning) return; const now = performance.now(); this.lastFrameTime = now; this.render(); this.updateUI(); requestAnimationFrame(() => this.gameLoop()); } render() { // Clear canvas this.ctx.fillStyle = '#000000'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); const cellSize = 20; // Render dungeon rooms this.ctx.fillStyle = '#333333'; for (const room of this.gameState.dungeon.rooms) { this.ctx.fillRect( room.position.x * cellSize, room.position.y * cellSize, room.width * cellSize, room.height * cellSize ); } // Render corridors this.ctx.fillStyle = '#444444'; for (const corridor of this.gameState.dungeon.corridors) { for (const point of corridor.path) { this.ctx.fillRect( point.x * cellSize, point.y * cellSize, cellSize, cellSize ); } } // Render items this.ctx.fillStyle = '#FFFF00'; for (const item of this.gameState.items) { this.ctx.fillRect( item.position.x * cellSize + 6, item.position.y * cellSize + 6, cellSize - 12, cellSize - 12 ); } // Render enemies this.ctx.fillStyle = '#FF0000'; for (const enemy of this.gameState.enemies) { if (enemy.health > 0) { this.ctx.fillRect( enemy.position.x * cellSize + 2, enemy.position.y * cellSize + 2, cellSize - 4, cellSize - 4 ); // Health bar this.ctx.fillStyle = '#800000'; this.ctx.fillRect( enemy.position.x * cellSize, enemy.position.y * cellSize - 8, cellSize, 4 ); this.ctx.fillStyle = '#FF0000'; const healthPercent = enemy.health / enemy.maxHealth; this.ctx.fillRect( enemy.position.x * cellSize, enemy.position.y * cellSize - 8, cellSize * healthPercent, 4 ); this.ctx.fillStyle = '#FF0000'; } } // Render player this.ctx.fillStyle = '#00FF00'; this.ctx.fillRect( this.gameState.player.position.x * cellSize + 2, this.gameState.player.position.y * cellSize + 2, cellSize - 4, cellSize - 4 ); // Player health bar this.ctx.fillStyle = '#004000'; this.ctx.fillRect( this.gameState.player.position.x * cellSize, this.gameState.player.position.y * cellSize - 8, cellSize, 4 ); this.ctx.fillStyle = '#00FF00'; const playerHealthPercent = this.gameState.player.health / this.gameState.player.maxHealth; this.ctx.fillRect( this.gameState.player.position.x * cellSize, this.gameState.player.position.y * cellSize - 8, cellSize * playerHealthPercent, 4 ); } updateUI() { document.getElementById('health').textContent = `${this.gameState.player.health}/${this.gameState.player.maxHealth}`; document.getElementById('level').textContent = this.gameState.player.level; document.getElementById('experience').textContent = this.gameState.player.experience; document.getElementById('room').textContent = this.gameState.currentRoom; document.getElementById('combat').textContent = this.gameState.isInCombat ? 'Yes' : 'No'; } log(message, type = 'info') { const logContainer = document.getElementById('game-log'); const entry = document.createElement('div'); entry.className = `log-entry ${type}`; entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`; logContainer.appendChild(entry); logContainer.scrollTop = logContainer.scrollHeight; // Keep only last 50 entries while (logContainer.children.length > 50) { logContainer.removeChild(logContainer.firstChild); } } } // Global functions for buttons window.newDungeon = function() { if (window.game) { window.game.generateNewDungeon(); } }; window.showPerformance = function() { if (window.game) { window.game.showPerformanceInfo(); } }; window.togglePause = function() { if (window.game) { window.game.isRunning = !window.game.isRunning; if (window.game.isRunning) { window.game.gameLoop(); } } }; // Start the game window.game = new SimpleGameRunner(); console.log('ðŸŽ® AI Dungeon Master started!'); console.log('Use WASD to move, Space to attack, E to use items'); </script> </body> </html>